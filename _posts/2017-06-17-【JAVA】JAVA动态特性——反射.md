### 【JAVA】JAVA动态特性——反射

> 反射，运行时（而非编译时），动态获取类型的信息（如：接口信息、成员信息、方法信息、够造方法信息等），根据这些动态获取到的信息创建对象、访问/修改成员、调用方法等


> 感谢老马说编程,更详细的内容请跳转<http://www.cnblogs.com/swiftma/p/6804342.html>

#### java.lang.Class

所有的类的根父类Object有一个方法，可以获取对象的Class对象：

`public final native Class<?> getClass() `

每一个对象都有getClass()方法来获取他的Class

Class有一个静态方法forName，可以根据类名直接加载Class，获取Class对象，比如：

```java
try{
  Class<?> cls = Class.forName("java.util.HashMap");
  System.out.println(cls.getName());
}catch(ClassNotFoundException e){
  e.printStackTrace();
}
```



Class有如下方法可以获取与名称有关的信息：

* public String getName()   用[表示数组，L表示类或接口，I表示int。。。很难用啊
* public String getSimpleName()  不带有包信息
* public String getCanonicalName() 带有包名的详细信息
* public String getPackage() 包信息

##### 类的加载

根据类名加载类的两个静态方法：

`public static Class<?> forName(String className)`

`public static Class<?> forName(String name,boolean initialize,ClassLoader loader)`

initializa表示加载后是否执行类的初始化代码（如static语句块），第一种相当于Class.forName(name,true,currentLoader)

className与Class.getName()的返回值一致

*基本类型不支持forName方法*

根据原始类型字符串够造Class对象方法：

~~~java
public static Class<?> forName(String className) throws ClassNotFoundException{
  if("int".equals(className)){
  	return int.class;
  }
  return Class.forName(className);
}
~~~

*数组类型可以用Class.getComponentType()获取元素类型*

*枚举类型有一个专门方法可以获取所有的枚举常量 public T[] getEnumConstants()*

反射存在的意义是增加结构的灵活性，但同时也是损失性能的，而且更容易出现运行时错误。慎用哦





















